// Generated by CoffeeScript 1.9.2
(function() {
  var Account, Room;

  Room = require("../models/Models").room;

  Account = require("../models/Models").account;

  module.exports = function(io) {
    return io.on("connection", function(socket) {
      var _playerId, _roomId;
      _playerId = null;
      _roomId = null;
      socket.on("join", function(data) {
        if (socket.request.session.playerId != null) {
          _playerId = socket.request.session.playerId;
        }
        if (data.roomId != null) {
          _roomId = data.roomId;
          socket.join(_roomId);
        } else {
          return socket.emit("error", {
            error: "Room ID was not included in the join request."
          });
        }
        return Account.findOne({
          _id: _playerId
        }).exec(function(err, account) {
          if ((err == null) && (account != null)) {
            return Room.findOne({
              _id: _roomId
            }).exec(function(err, room) {
              var definition, j, k, l, len, len1, len2, len3, m, player, ref, ref1, ref2, ref3;
              ref = room.players;
              for (j = 0, len = ref.length; j < len; j++) {
                player = ref[j];
                if (player._id.equals(account._id)) {
                  socket.emit("message", {
                    message: "Account already in room"
                  });
                  return;
                }
              }
              socket.emit("word", {
                word: room.word
              });
              ref1 = room.definitions;
              for (k = 0, len1 = ref1.length; k < len1; k++) {
                definition = ref1[k];
                socket.emit("definition", definition);
              }
              ref2 = room.players;
              for (l = 0, len2 = ref2.length; l < len2; l++) {
                player = ref2[l];
                socket.emit("playerJoin", {
                  username: player.username
                });
              }
              io.to(_roomId).emit("playerJoin", {
                username: account.username
              });
              ref3 = room.definitions;
              for (m = 0, len3 = ref3.length; m < len3; m++) {
                definition = ref3[m];
                if (_playerId === definition.playerId) {
                  socket.emit("hideInput");
                }
              }
              room.players.push(account);
              return room.save();
            });
          } else {
            return socket.emit("message", {
              error: "Couldn't find the account '" + _playerId + "'"
            });
          }
        });
      });
      socket.on("definition", function(data) {
        if ((_playerId != null) && (_roomId != null)) {
          return Room.findOne({
            _id: _roomId
          }).exec(function(err, room) {
            var definition, numConnectedClients;
            if (err || (room == null)) {

            } else {
              definition = {
                definition: data.definition,
                playerId: _playerId
              };
              room.definitions.push(definition);
              room.save();
              io.to(_roomId).emit("definition", definition);
              numConnectedClients = Object.keys(io.nsps["/"].adapter.rooms[_roomId]).length;
              if (room.definitions.length >= numConnectedClients) {
                return io.to(_roomId).emit("done", {
                  message: "All definitions have been submitted"
                });
              }
            }
          });
        }
      });
      socket.on("disconnect", function() {
        Account.findOne({
          _id: _playerId
        }).exec(function(err, account) {
          if ((err != null) || (account == null)) {
            socket.emit("message", {
              message: "Error finding account when destroying."
            });
            return console.log("Error finding account. There may be duplicates in room " + _roomId);
          } else {
            return io.to(_roomId).emit("playerLeave", {
              username: account.username
            });
          }
        });
        return Room.findOne({
          _id: _roomId
        }).exec(function(err, room) {
          var i, j, ref;
          if ((err == null) && (room != null)) {
            for (i = j = ref = room.players.length - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
              if (room.players[i]._id.equals(_playerId)) {
                room.players.splice(i, 1);
              }
            }
            return room.save();
          }
        });
      });
      return socket.on("vote", function(data) {
        return Room.findOne({
          _id: _roomId
        }).exec(function(err, room) {
          return room.definitions.forEach(function(entry, id) {
            if (entry.playerId === data.playerId) {
              entry.votes.push(data.playerId);
              room.save();
            }
            return io.to(_roomId).emit("vote", {
              playerId: data.playerId
            });
          });
        });
      });
    });
  };

}).call(this);
